from django.db import models
from django.utils.timezone import now
from django.core.urlresolvers import reverse

from bitcoins.bci import set_bci_webhook

from bitcash.settings import BASE_URL

from utils import uri_to_url


class DestinationAddress(models.Model):
    """
    What's uploaded by the user.
    """
    uploaded_at = models.DateTimeField(auto_now_add=True, db_index=True)
    b58_address = models.CharField(blank=False, null=False, max_length=34, db_index=True)
    retired_at = models.DateTimeField(blank=True, null=True, db_index=True)
    merchant = models.ForeignKey('merchants.Merchant', blank=False, null=False)

    def __str__(self):
        return '%s: %s' % (self.id, self.b58_address)

    def create_new_forwarding_address(self):
        callback_uri = reverse('process_bci_webhook')
        user = self.merchant.app_user
        forwarding_address = set_bci_webhook(
                dest_address=self.b58_address,
                callback_url=uri_to_url(BASE_URL, callback_uri),
                user=user)
        ForwardingAddress.objects.create(
                b58_address=forwarding_address,
                destination_address=self,
                merchant=self.merchant)
        return forwarding_address


class ForwardingAddress(models.Model):
    """
    One-time recieving address generated by blockchain.info
    """
    generated_at = models.DateTimeField(auto_now_add=True, db_index=True)
    b58_address = models.CharField(blank=False, null=False, max_length=34,
            db_index=True, unique=True)
    retired_at = models.DateTimeField(blank=True, null=True, db_index=True)
    destination_address = models.ForeignKey(DestinationAddress, blank=True, null=True)

    # technically, this is redundant through DestinationAddress
    # but having it here makes for easier querying
    merchant = models.ForeignKey('merchants.Merchant', blank=False, null=False)

    def __str__(self):
        return '%s: %s' % (self.id, self.b58_address)

    def get_transaction(self):
        return self.btctransaction_set.last()

    def get_all_transactions(self):
        return self.btctransaction_set.all()

    def get_current_shopper(self):
        return self.shopper_set.last()


class BTCTransaction(models.Model):
    """
    Deposits that affect our users.

    Both ForwardingAddress (initial send) and DestinationAddress (relay) are
    tracked separately in this same model.
    """
    added_at = models.DateTimeField(auto_now_add=True, db_index=True)
    txn_hash = models.CharField(max_length=64, blank=True, null=True,
            unique=True, db_index=True)
    satoshis = models.BigIntegerField(blank=True, null=True, db_index=True)
    conf_num = models.PositiveSmallIntegerField(blank=True, null=True, db_index=True)
    irreversible_by = models.DateTimeField(blank=True, null=True, db_index=True)
    suspected_double_spend_at = models.DateTimeField(blank=True, null=True, db_index=True)
    # only ONE of these will ever have a match (the two txns are two separate entries)
    forwarding_address = models.ForeignKey(ForwardingAddress, blank=True, null=True)
    destination_address = models.ForeignKey(DestinationAddress, blank=True, null=True)
    # This is redundant through Address models, but having it here makes easier queries
    merchant = models.ForeignKey('merchants.Merchant', blank=False, null=False)
    # TODO: add shopper here?
    # TODO: add currency (USD, EUR, etc)?
    fiat_ammount = models.DecimalField(blank=True, null=True, max_digits=5, decimal_places=2)

    def __str__(self):
        return '%s: %s' % (self.id, self.b58_address)

    @classmethod
    def process_forwarding_webhook(cls, txn_hash, satoshis, conf_num, forwarding_addr):
        """
        Blockchain.info Forwarding Address
        """

        # TODO: send email notifications

        btc_txn = cls.objects.get(txn_hash=txn_hash)

        if btc_txn:
            # already had txn in database

            # run defensive checks
            msg = '%s != %s' % (btc_txn.satoshis, satoshis)
            assert btc_txn.satoshis == satoshis, msg
            msg = '%s != %s' % (btc_txn.forwarding_address.b58_address, forwarding_addr)
            assert btc_txn.forwarding_address.b58_address == forwarding_addr, msg

            # update # confirms
            if conf_num < btc_txn.conf_num:
                msg = 'BCI Reports %s confirms and previously reported %s confirms for txn %s'
                msg = msg % (conf_num, btc_txn.conf_num, txn_hash)
                raise Exception(msg)

            elif conf_num == btc_txn.conf_num:
                # Same #, no need to update
                pass

            else:
                # Incrase conf_num
                btc_txn.conf_num = conf_num
                if conf_num >= 6 and not btc_txn.irreversible_by:
                    btc_txn.irreversible_by = now()
                btc_txn.save()

        else:
            forwarding_obj = ForwardingAddress.objects.get(b58_address=forwarding_addr)
            if conf_num >= 6:
                irreversible_by = now()
            else:
                irreversible_by = None
            cls.objects.create(
                    txn_hash=txn_hash,
                    satoshis=satoshis,
                    conf_num=conf_num,
                    irreversible_by=irreversible_by,
                    forwarding_address=forwarding_obj,
                    merchant=forwarding_obj.merchant,
                    )

    @classmethod
    def process_destination_webhook(cls, txn_hash, satoshis, conf_num, destination_addr):
        # User's final address
        # This will be implemented with blockcypher
        pass
