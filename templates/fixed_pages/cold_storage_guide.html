{% extends "blog_post_base.html" %}

{% block main_section %}

<h2>Background</h2>

<p>
Bitcoin is the world's most popular cryptocurrency, with currently about $10 billion USD in circulation.
This guide to storing bitcoin assumes you have some understanding of the Bitcoin protocol.
If you want to learn more about Bitcoin, you can get started at <a href="https://www.weusecoins.com/en/">weusecoins.com</a> or check out the excellent <a href="http://letstalkbitcoin.com/e61-lets-talk-bitcoin-for-new-users/">Let's Talk Bitcoin Podcast</a>.
</p>

<p>
The problem with keeping Bitcoin private keys on an Internet connected machine is that if that machine were compromised the bitcoin can be stolen instantly and irreversibly.
<a href="http://www.wired.com/wiredenterprise/2013/11/inputs/">Stories</a> <a href="http://venturebeat.com/2013/04/03/bitcoin-wallet-instawallet-hacked/">keep</a> <a href="https://en.bitcoin.it/wiki/MyBitcoin">popping</a> <a href="http://arstechnica.com/business/2012/03/bitcoins-worth-228000-stolen-from-customers-of-hacked-webhost/">up</a> <a href="http://www.forbes.com/sites/timworstall/2012/05/15/another-bitcoin-theft-at-bitconia/">every</a> <a href="http://www.pcworld.com/article/230377/worlds_first_virtual_heist_bitcoin_user_loses_500000.html">month</a> <a href="http://www.theverge.com/2012/9/5/3293375/bitfloor-bitcoin-exchange-suspended-theft">about</a> <a href="http://siliconangle.com/blog/2011/08/01/third-largest-bitcoin-exchange-bitomat-lost-their-wallet-over-17000-bitcoins-missing/">bitcoin</a> <a href="http://www.btcnn.com/2011/10/bitcoin7com-bitcoin-exchange-gets.html">wallets</a> being hacked or lost, as well as <a href="http://bitcoinmagazine.com/5889/sec-files-charges-against-bitcoin-ponzi-mastermind-trendon-shavers/">outright scams</a> where people believed they were holding bitcoin that they actually weren't.
In private, we hear many stories even from Bitcoin veterans about the embarrassing ways in which they lost hundreds of thousands of dollars worth of bitcoin.
As bitcoin's value and popularity rises, we unfortunately expect to see these events become much more common.
</p>

<a id="table_of_contents"></a>
<h2>Table of Contents</h2>
<p>In this guide, we will explain the following steps to keeping your bitcoin secure:</p>
<ol>
<li><a href="#ingredients">Choose the right equipment to secure your bitcoin</a></li>
<li><a href="#setup_airgap">Setup a secure environment on an airgap machine</a></li>
<li><a href="#verify_sw">Verify software before using it</a></li>
<li><a href="#generate_keys">Generate private keys on airgap machine</a></li>
<li><a href="#encrypt">Encrypt private keys and move them to redundant offline USB drives in multiple locations</a></li>
<li><a href="#shamir">Divide the decryption key using Shamir's Secret Sharing Scheme and give those Shamir Shares to trusted guardians for recovery</a></li>
</ol>

<p>We also include a long <a href="#technical_notes">Technical Notes Section</a> at the end that explains a lot of these choices and their tradeoffs in more detail.</p>

<hr />

<h2>Intro</h2>

<p>
Thanks for joining us on this journey! If at any point you're confused, don't blindly power through.
When storing bitcoin, mistakes can be deadly.
It only takes one slip-up to later lose all of your bitcoin, and if that happens it's unlikely you'd find out until it's too late.
The devil is in the details.
</p>

<hr />

<a id="ingredients"></a>
<h3>1) Choose the right equipment to secure your bitcoin</h3>

<ul>
<li>A very basic laptop with preferably at least 1GB of RAM. The exact system requirements are <a href="https://tails.boum.org/doc/about/requirements/">here</a>. You also want at least two USB ports and a hard-drive of the old fashioned spinning disk variety (not flash memory, <a href="#flash_destruction">more on that later</a>)... In other words, this could be a very old machine.</li>
<li>3-5 <b>different</b> brands of USB drives per secure offsite storage location. With 3-4 locations recommended, that's at least 9 different pen drives. Storage space per drive won't be a problem, as just 1GB will hold ~5MM private keys. You could probably get away with fewer redundant copies, but since <a href="http://www.amazon.com/b/ref=sr_aj?node=3151491&ajr=0">USB drives sell for ~$10</a>, there's no reason to skimp.</li>
<li>A copy of <a href="https://github.com/coinsafe/cold-storage">all the files referenced in this post</a> including <a href="https://github.com/richardkiss/pycoin/">pycoin</a> and <a href="https://github.com/matja/bitcoin-tool">bitcoin-tool</a>, loaded onto a USB drive. Be sure to clearly designate this USB as the drive that can connect to an online computer, as all the others can't.</li>
<li>Paper and pen. <a href="http://en.wikipedia.org/wiki/Acid-free_paper#Archival_paper">Acid-free archival paper</a> and <a href="http://www.amazon.com/Sakura-30081-Micron-Blister-0-20-mm/dp/B001CRI6O2">a pH neutral archival pen</a> would be nice.</li>
<li>3-4 Electromagnetic Pulse (EMP) Faraday Bags, one for each secure location. <a href="http://www.amazon.com/EMP-Cover-Bag-Kit-Electronics/dp/B00BZBRCZE/">Amazon has large ones</a> and <a href="http://www.disasterstuff.com/store/pc/viewPrd.asp?idproduct=1398">disasterstuff.com carries smaller ones that are much more affordable</a>.</li>
</ul>

<hr />

<a id="setup_airgap"></a>
<h3>2) Setup a secure environment on an airgap machine
</h3>

<p>
While it would be possible to do this on a proprietary operating system, at we strongly recommend Linux over Windows/OSX because Linux is open source.
If you're comfortable taking risks with your funds, feel free to use any operating system you like.
That said, if you're comfortable taking risks, why are you interested in cold storage in the first place? :)
</p>

<p>
There are many flavors of Linux to choose from, but at CoinSafe we like Tails because <a href="http://www.linuxjournal.com/content/linux-distro-tales-you-can-never-be-too-paranoid">it defaults to the most secure/paranoid setting</a> and deletes everything on shutdown. Worried about a <a href="http://en.wikipedia.org/wiki/Cold_boot_attack">Cold Boot Attack</a>?
No worries, <a href="https://tails.boum.org/doc/advanced_topics/cold_boot_attacks/index.en.html">you're covered against that</a>.
Tails is particularly nice because later when you spend your bitcoin, you don't need to install an OS, create a spend transaction, and then wipe the machine when you're done. With Tails, you just boot up and you're ready to go.
When you shut down, you're done. One noteworthy downside is that Tails ships with limited software and installing other packages is tricky.
</p>

<p>
Start by carefully following <a href="https://tails.boum.org/download/index.en.html">the installation instructions for Tails</a>.
You can either burn the Live OS onto a DVD or put in on a thumb drive. At CoinSafe, we prefer to boot from a DVD-R because:
</p>
<ol>
<li>We know it's not editable in the future.</li>
<li>When working with pen drives there's always a risk that you'll select/eject the wrong one (the bitcoin private keys will also be on a USB drive). One less writeable USB drive means one less place to mess up.</li>
</ol>
<p>Either way, be sure to closely follow the steps in the Tails guide to verify that the ISO image you download is genuine.</p>

<p>
When you Boot Tails, you want to boot in advanced mode so that you can access the internal drive.
Set a password by selecting <b>Yes</b> under <b>More options</b> on boot.
You only need this password for as long as the machine is booted, once you shut the machine down you can destroy it.<br />
<img src="https://s3.amazonaws.com/coinsafe-public/tails_boot_screenshot_small.jpg" width="100%">
</p>

<p>
For an extra measure of safety, you want to wipe the local hard drive.
After you get the system up and running you will <b>never</b> leave anything of value on the machine.
When booting from a Tails Live OS disk, you can find the <b>Disk Utility</b> app in <b>Applications</b> -> <b>System Tools</b>-> <b>Disk Utility</b>:<br />
<img src="https://s3.amazonaws.com/coinsafe-public/tails_disk_utility.png" width="100%" />
</p>

<p>
<b>You need to be 100% sure this machine won't connect to the internet</b>.
The best solution is to physically remove the wireless card and put <a href="http://www.amazon.com/gp/product/B000X5G6O6/">epoxy potting compound</a> in the ethernet port, but it depends on how careful you want to be.
Some machines have switches to disable these features.
If you're interested, security expert Bruce Schneier has <a href="https://www.schneier.com/blog/archives/2013/10/air_gaps.html">a nice piece on airgap machines here</a>.
</p>

<p>
You're going to generate passwords using <code>/dev/random</code> as your <a href="http://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator">CSPRNG</a>.
Out of an abundance of caution, you first want to top up the entropy pool so that an attacker couldn't just duplicate these steps to "randomly" generate your same private keys.
Provide <code>/dev/random</code> with some more environmental noise by following two steps:</p>
<ul>
<li>Move the mouse around as randomly as you can for at least 30 seconds (more time welcome).</li>
<li>Open a text pad and bang on the keyboard for hundreds of characters (more welcome). Try to randomize not just what you type, but <a href="https://github.com/torvalds/linux/blob/0891ad829d2a0501053703df66029e843e3b8365/drivers/char/random.c#L753">the timing between keystrokes</a> as well</li>
</ul>

<p>
You're going to need a place to put the private keys once we generate them.
Leaving them around unencrypted (even temporarily) creates an attack vector, so the solution is to create a small (say ~500MB) encrypted partition on your internal drive.
We encrypt the drive using a long password that you <b>don't</b> write down, so even you won't have access to the drive after unmounting it.
</p>

<a id="flash_destruction"></a>
<p>
You could use a USB pen drive here, but there's one issue: it's <a href="http://security.stackexchange.com/questions/5662/is-it-enough-to-only-wipe-a-flash-drive-once">very</a> <a href="https://www.schneier.com/blog/archives/2011/03/erasing_data_fr.html">hard</a> to securely wipe a flash drive (there is <a href="http://superuser.com/questions/373288/will-microwaving-a-flash-drive-destroy-the-data-on-it">a more violent approach</a> if you like pyrotechnics).
You'd probably be okay if you created an encrypted partition on that flash drive with a decryption key that you don't write down.
At CoinSafe, we prefer the redundancy and simplicity of shredding our files before unmounting and destroying the partition, so we'll stick with old-fashioned spinning-disk hard drives.
</p>

<p>
Perhaps you're noticing a pattern here: a good security practice is about setting the proper defaults.
If you accidentally mess up a small detail it shouldn't put everything at risk...
You may decide you want to start the process over again to be safe, but that is much better than the alternative: one day waking up to find you've lost your bitcoin instantly and irreversibly!
</p>

<p>
Since it's going to be copy-pasted, the password for our encrypted drive can be quite long.
We've arbitrarily chosen 100 characters here:<br />
<code>
$ &lt; /dev/random tr -cd [:graph:] | head -c${1:-100}; echo <br />
4ZRgi}eEyEv5_;3|@{^{9OK+\KHvrlTG*GVP?f"%'?dXBv$Q37.[fG~k/M#@D53saj@[0z`QH7q49C
</code><br />
(If your terminal appears frozen, it probably means you've emptied your entropy pool and <code>/dev/random</code> is blocking as it waits for more entropy, just tap on some keys to add more entropy. And of course, don't use the above password yourself.)</p>

<p>
You can find more password generating tips <a href="http://www.howtogeek.com/howto/30184/">here</a> if you're interested, but note that not all of these are secure.
</p>

<p>
We create the partition in ext2 format, since ext2 doesn't support <a href="http://en.wikipedia.org/wiki/Journaling_file_system">journaling</a>:<br />
<img src="https://s3.amazonaws.com/coinsafe-public/create_encrypted_partition1.png" /><br />
<img src="https://s3.amazonaws.com/coinsafe-public/create_encrypted_partition2.png" />
</p>

<p>Now that you're done with this password, you should probably close the window that generated it so that it's truly gone forever:<br />
<code>$ exit</code>
</p>

<a id="verify_sw"></a>
<h3>3) Verify software before using it</h3>

<p>
Before running any software, you need to be sure that it hasn't been tampered with.
Here are the software packages we want to download, as well as the SHA-256 of their <code>.zip</code> file from github:
</p>
<ul>
<li>All the files in <a href="https://github.com/coinsafe/cold-storage">the  coinsafe/cold-storage github repo</a> as of commit <code>6763dba484f08d3ac72a8e615d88cf0062044f0d</code>. You can download the <code>.zip</code> file <a href="https://github.com/coinsafe/cold-storage/archive/6763dba484f08d3ac72a8e615d88cf0062044f0d.zip">here</a> and verify its SHA-256 is <code>087b21e183ba8352556a1f0c46041c8dcd9f5c00bb8376950150692e2942d6d4</code>.
</li>
<li>All the files in <a href="https://github.com/richardkiss/pycoin/">the richardkiss/pycoin github repo</a> as of commit <code>04ff560eaa5b6733a9dc12a1a3a7816ff71bbe59</code>. You can download the code <code>.zip</code> file <a href="https://github.com/richardkiss/pycoin/archive/04ff560eaa5b6733a9dc12a1a3a7816ff71bbe59.zip">here</a> and verify its SHA-256 is <code>4bb0ff77a4c50f33118371c5cadd7ad63ee90833693813595a41afe4a43d324b</code></li>
<li>All the files in <a href="https://github.com/matja/bitcoin-tool">the matja/bitcoin-tool github repo</a> as of commit <code>22aaadf6c20ca65e531cf9c77538fb1b2fdc4698</code>. You can download the code <code>.zip</code> file <a href="https://github.com/matja/bitcoin-tool/archive/22aaadf6c20ca65e531cf9c77538fb1b2fdc4698.zip">here</a> and verify its SHA-256 is <code>eb9e58ab3dd9f43571c1c213778a24ac0cf24dc171a983ff769726437d548550</code></li>
</ul>

<p>
To calculate the SHA-256 of each file, run the following command:<br />
<code>$ shasum -a 256 FILENAME_HERE.zip</code></p>

<a id="generate_keys"></a>
<h3>4) Generate private keys on airgap machine</h3>

<p>
To generate your bitcoin private keys, you'll be using <a href="https://github.com/richardkiss/pycoin/">pycoin</a>, which is a very nice open source library by <a href="http://blog.richardkiss.com/">Richard Kiss</a>.
The security of your private keys is only as good as your random number generator, so you'll be using <code>/dev/random</code> because it was designed to solve this very problem.
If you were just generating a handful of addresses then you could solve this problem by rolling lots of dice, but at scale you'll quickly get tendonitis!
</p>

<p>
<a href="https://github.com/coinsafe/cold-storage/blob/master/generate_wallets.py">Here's a script that will generate 100,000 bitcoin private keys and save them to your temporary encrypted drive</a>.
On a 5+ year old laptop it took CoinSafe ~5 hours to generate 100,000 private keys (interpreted languages are pretty slow).
Be sure that if you leave the room during this time you are certain that nobody else has physical access to your equipment.
</p>

<p>
Copy <code>pycoin</code> and the script to your partition (using your USB drive that's safe for online machines) and then run the script:<br />
<code> amnesia@amnesia:/media/wipeout/pycoin-master$ python generate_wallets.py </code> <br />
(this may take a while)
</p>

<p>
Yay, you now have 100,000 properly formed addresses with their corresponding private keys: <br />
<code> $ head -n 3 /media/wipeout/btc_keys_20140113_2058.csv <br />
born_at,wif,public_bitcoin_address <br />
2014-01-13 20:58:10.935709,L5K4HinCrDKRGYgGesRCjJ9gaZaga5f6McJpSZ8yvgnfo81pqVYe,1NsVTcFAd73y5Q4vQLMGNvSkYf2boKdaLs <br />
2014-01-13 20:58:11.106921,KwcYrkQj5Sx8HXtCvyZcHdYiwDfn98X4Fw8iga2mTvPyiE46TMnw,1G4R5kJ4g9ZznUWUSHi66o35hRmDjafMJH
</code>
(Obviously, don't use these addresses for anything. You will be robbed instantly.)
</p>

<p>
Looking good, but are they valid? Might there be a bug in <code>pycoin</code> (or one of the libraries it depends on)?
It would be terrible if you sent bitcoin to one of these addresses only to later find out that there was a problem with the corresponding private key.
The pycoin library is great (and open source), but in these situations you can never be too sure.
We at CoinSafe use <a href="https://github.com/matja/bitcoin-tool">bitcoin-tool</a> to verify each address before committing it to storage.
There are <a href="#wallet_libraries">many other libraries</a> you could use as well.
</p>

<p>
<a href="https://github.com/coinsafe/cold-storage/blob/master/test_wallets.py">Here's a script that will call bitcoin-tool on each entry in your <code>csv</code> file and confirm it's valid</a>.
Since <code>bitcoin-tool</code> is written in C, it's ~50x faster than <code>pycoin</code>.
CoinSafe has now tested this on over 1.5 million bitcoin private keys and has yet to find a single discrepancy.
That's a good vote of confidence for both <code>pycoin</code> and <code>bitcoin-tool</code>.
While testing the wallet addresses isn't strictly necessary, at CoinSafe we do it for all of our addresses.
</p>

<p>Copy the script to <code>/media/wipeout/</code> and run it to confirm that your bitcoin addresses are valid:<br />
<code>$ python test_wallets.py</code>
</p>

<hr />

<a id="encrypt"></a>
<h3>5) Encrypt private keys and move them to redundant offline USB drives in multiple locations</h3>

<p>
Now that you have a file with valid bitcoin private keys and their corresponding public addresses, you need to encrypt them so you can move them off your temporary drive.
This encryption key is really important, because anyone with it and the USB drive could steal your bitcoin instantly and irreversibly.
This is the last line of defense between an attacker and all of your bitcoin!
</p>

<p>
Unfortunately, humans <a href="http://en.wikipedia.org/wiki/Password_strength#Human-generated_passwords">are terrible at generating good passwords</a>.
xkcd has <a href="http://preshing.com/20110811/xkcd-password-generator/">an excellent comic explaining this problem</a>:<br />
<img src="https://s3.amazonaws.com/coinsafe-public/password_strength.png" width="100%" /><br />
(Absolutely do not make your password <b>correct horse battery staple</b>.)
</p>

<p>
Humans also have a natural tendency to re-use passwords, because it makes our lives easier.
Don't fall for that trap! If your password was compromised somewhere else, it'd be compromised here, too.
Remember that in security you're only as strong as your weakest link.
</p>

<p>
Let's assume our skilled attacker has somehow gotten their hands on our encrypted USB and is using a large-scale distributed computer network (or supercomputer) to brute force the password by making one trillion guesses per second.
Fortunately, we can easily thwart their attack by increasing the length of our password.
</p>

<p>
<code>tr</code> with the <code>graph</code> flag uses 94 different characters, so one trillion guesses per second means that a 20 character password would take <a href="https://www.google.com/search?q=(94**20)%2F(1%2C000%2C000%2C000%2C000*60*60*24*365*1000)%2F2">on the order of 40,000,000,000,000,000 <b>millennia</b> to brute force</a>.
For those with a cryptography background, you'll recognize this as <a href="https://www.google.com/search?q=lg(94**20)">131 bits of entropy</a>.
</p>

<p>Thankfully, <code>/dev/random</code> comes to the rescue again (see <a href="#words_vs_letters">here</a> if you're curious why we use random letters over words):<br />
<code>
$ &lt; /dev/random tr -cd [:graph:] | head -c${1:-20}; echo
</code>
</p>

<p>
Now, <b>carefully</b> write down that password on a piece of paper and do not let it out of your sight.
As soon as your are able to commit it to memory, destroy the paper (more details <a href="#destroy_pw">here</a>).
</p>

<p>You're going to use <code>OpenSSL</code> to salt and encrypt our file of private keys using AES256 with a CBC cipher:<br />
<code>
$ openssl enc -aes-256-cbc -salt -a -in /media/wipeout/btc_keys_20140113_2058.csv -out /media/wipeout/btc_keys_20140113_2058.enc
</code><br />
(more info <a href="#openssl_b64">here</a> if you're curious)
</p>

<p>Did it work? Try decrypting the file:<br />
<code>
$ openssl enc -d -aes-256-cbc -salt -a -in /media/wipeout/btc_keys_20140113_2058.enc | head
</code>
</p>

<p>To be able to quickly verify the validity of your encrypted file in the future, calculate the SHA256 hash of the file and write it down:<br />
<code>
$ shasum -a 256 /media/wipeout/btc_keys_20140113_2058.enc
</code>
</p>

<p>
You'll store redundant copies of this in multiple safe places so that if you're ever in doubt about a file's integrity we can easily run this command to verify it is exactly what you expect.
If an attacker got a hold of the SHA256 value, it wouldn't be of any use to them.
</p>

<p>
Now take that encrypted file and put a copy of it on each of your USB thumb drives.
Before getting started with the thumb drives, wipe them with Tails' Disk Utility.
We recommend formatting them in FAT32 since it is the most universally compatible.
In practice, since the only machine that will ever touch this USB drive is the one running Tails, it doesn't particularly matter.
</p>

<p>Now it's simply a matter of inserting each drive and copying the encrypted file over to it:<br />
<code>
$ cp /media/wipeout/btc_keys_20140113_2058.enc /media/securedrive1/
</code>
</p>

<p>Confirm the copy was successful for each drive by running the same command as before:<br />
<code>
$ shasum -a 256 /media/securedrive1/btc_keys_20140113_2058.enc
</code>
</p>

<p>
What's the point of having a bunch of private keys if you can't easily access the corresponding bitcoin public addresses to go with them?
Generate a file that has just the public addresses (no private keys) like this:<br />
<code>
$ cut -d "," -f1,3 /media/wipeout/btc_keys_20140113_2058.csv > /media/wipeout/btc_public_addresses.csv
</code>
</p>

<p>Before sending this information to a less secure environment, verify that cut worked:<br />
<code>
amnesia@amnesia:~$ head -n 3 /media/wipeout/btc_public_addresses.csv <br />
born_at,public_bitcoin_address <br />
2014-01-13 20:58:10.935709,1NsVTcFAd73y5Q4vQLMGNvSkYf2boKdaLs <br />
2014-01-13 20:58:11.106921,1G4R5kJ4g9ZznUWUSHi66o35hRmDjafMJH
</code><br />
Looking good, only public addresses here!
</p>

<p>Copy that file to a separate USB drive that is not destined for such secure storage (your web server, for example) and has never held sensitive information on it:<br />
<code>
$ cp /media/wipeout/btc_public_addresses.csv /media/lesssecuredrive/
</code>
</p>

<p>
<b>This is the only USB drive that is safe to connect to an internet connected machine</b>.
You can sleep well at night with these public bitcoin addresses on your web server, or even published on our website so your customers can send you bitcoin.
The only copies of the private keys are encrypted on those USB drives that are heading to a secure location shortly.
</p>

<p>Since you've diligently followed these instructions and tested everything along the way, you can now get rid of all the copies on your local machine:<br />
<code>
$ shred -u /media/wipeout/btc_keys_20140113_2058.enc
</code>
<code>
$ shred -u /media/wipeout/btc_keys_20140113_2058.csv
</code><br />
You can <a href="http://www.gnu.org/software/coreutils/manual/html_node/shred-invocation.html">read more about shred here</a>.
</p>

<p>
You need to get these USBs somewhere safe.
At CoinSafe, we use bank vaults at multiple different banks in multiple states to ensure reliability.
Be sure to choose banks that require both the key as well as a matching ID and signature (the signature is admittedly a pretty a weak security mechanism).
</p>

<p>
During Hurricane Sandy, people learned the hard way that bank vaults are great at preventing theft and fire, but not that great at staying dry.
At CoinSafe, we place our USB drives in ziplock bags for added caution.
If you're in a flood-prone area, you may want to choose a safe higher off the ground for a lower flood risk.
</p>

<p>
One risk of storing the USB drives that still remains is an Electromagnetic Pulse (EMP).
For this, place your USB drives (which are already in plastic bags) inside of the Faraday Bags you bought earlier.
</p>

<p>
A <a href="http://superuser.com/questions/395876/is-flash-storage-affected-by-magnetic-fields">very</a> <a href="http://superuser.com/questions/338641/is-it-possible-to-wipe-ssd-with-strong-magnetic-force">strong</a> magnet could still damage the USB drives, but that would require a coordinated attack and would provide no benefit to the attacker.
Your geographically diverse locations should help us there.
<b>Don't tell anyone which bank vaults you use</b>.
</p>

<p>
A rogue bank employee accessing your USB drives would be a significant security breach, but without the decryption key in your head they wouldn't be able to decrypt your file.
</p>

<hr />

<a id="shamir"></a>
<h3>6) Divide the decryption key using Shamir's Secret Sharing Scheme and give those Shamir Shares to trusted guardians for recovery</h3>

<p>
But wait, what if you forget the password or get hit by a bus?
Would your clients/heirs lose their funds?
This single point of failure presents too great of a risk, so you'll use <a href="http://en.wikipedia.org/wiki/Shamir's_Secret_Sharing">Shamir's Secret Sharing Scheme</a> to guard against this risk.
</p>

<p>
For how useful it is, there are surprisingly few open source SSSS implementations (and some have no documentation).
One of the most reputable of them is <a href="http://point-at-infinity.org/ssss/">ssss</a>, which conveniently comes pre-installed on Tails and many Linux distros.
Another cool implementation you can play around with is <a href="http://passguardian.com/">passguardian.com</a>, though we prefer <a href="http://point-at-infinity.org/ssss/">ssss</a> because it has been around longer and it's easier to write a testing suite for (see <a href="#test_shamir">below</a>).
</p>

<p>
A warning on dividing secrets: this is one area of cryptography that is most misunderstood because unlike encryption and hash functions, there's little reason to use them often.
As a general rule: <b>if you're dividing a secret and not using Shamir's Secret Sharing Scheme, you're almost certainly doing it wrong</b>.
Read more <a href="#dividing_secrets">here</a>.
</p>

<p>
At CoinSafe, we hand out 1 share to each of 11 highly trustworthy people who we believe to have excellent judgement.
A simple majority of them (6 people), will be able to generate our decryption key, while anything less reveals nothing.
You could edit these numbers however you see fit, but it's important that no individuals have enough shares to easily collude and discover your password.
You also want to have enough shares so that a few of them could lose their shares and you'd still be OK.
For everyone's safety, don't tell even the guardians who the other guardians are.
<br />

<p>
Here's the output for a lower threshold (3 of 5) and using the secret "Hello World".
This should <b>absolutely not</b> be your secret:
</p>
<code>
$ ssss-split -n 5 -t 3 <br />
Generating shares using a (6,11) scheme with dynamic security level. <br />
Enter the secret, at most 128 ASCII characters: Using a 88 bit security level. <br />
1-52e1155d6693b39cb2fdac <br />
2-afa09208f99f52f94a08d9 <br />
3-7faaaac2a7f6677fbbdeba <br />
4-ed036a854cefd067fb5067 <br />
5-3d09524f1286e5e10a8616 <br />
</code><br />
(due to intentional randomness, you will get different shares every time you run <code>ssss</code>.)
</p>

<p>You can test that any three of these do in fact work like this (we've randomly chosen share 1, 3, and 5):<br />
<code>
$ $ ssss-combine -t 3 <br />
Enter 3 shares separated by newlines: <br />
Share [1/3]: 1-52e1155d6693b39cb2fdac <br />
Share [2/3]: 3-7faaaac2a7f6677fbbdeba <br />
Share [3/3]: 5-3d09524f1286e5e10a8616 <br />
Resulting secret: hello world
</code>.
</p>

<p>
Given the distributed and semi-anonymous nature of this storage, you'd like a way to verify the validity of a share in the future should we ever need it.
This also protects us against <a href="http://en.wikipedia.org/wiki/Typographical_error">fat-fingering</a>.
Calculate the SHA256 of each share and store only the hashes of each share in the safe as well:<br />
<code>
$ echo -n SHARE_GOES_HERE | shasum -a 256
</code><br />
(the <code>-n</code> flag is <a href="http://stackoverflow.com/questions/3358420/generating-a-sha256-from-the-linux-command-line">so that you don't include the newline character</a>)
</p>

<a id="test_shamir"></a>
<p>
These shares look good, but before handing them out you have to know that any combination of them will definitely work.
At CoinSafe, we've written <a href="https://github.com/coinsafe/cold-storage/blob/master/test_ssss.py">a script to verify every combination of Shamir Shares</a>, and to our knowledge this is the only Shamir Secret Sharing Scheme test suite that exists.
This was surprising to us, because you'd think something important enough to use Shamir's Secret Sharing Scheme for would be important enough to test that it worked!
Copy this file to your encrypted disk and replace the <code>SECRET</code> (<b>hello world</b> in this example) and <code>SHARES</code> variables with your real values:<br />
<code>
$ python test_ssss.py
</code>
</p>

<p>Great, the shares check out. Now shred that file (it has your secret shares in it) to be safe:<br />
<code>
$ shred -u test_sss.py
</code>
</p>

<p>Unmount the empty drive and poof, everything that was ever inside it is <b>gone forever</b>.<br />
</p>

<p>
Now, (painstakingly) transcribe those shares manually onto your archival paper.
You must be 100% certain that your shares are copied correctly, otherwise they could be worthless when you need them most.
One safe way to handle this issue is to re-run the previous test in <code>test_ssss.py</code>, only this time use values manually typed in from the handwritten text (not copy-pasted from the original share generation).
</p>

<p>
Deliver the one share to each of your guardians.
If manual delivery for each person isn't an option (perhaps they live in another country) consider using other secure delivery channels, like SSHing into their machine for example.
Don't just mail/fedex all of the shares; the small risk of an analog MITM (man-in-the-middle) attack could have terrible consequences.
</p>

<p>
Be sure your Shamir Shares are geographically dispersed.
In the very unlikely event that a single city is wiped out by an act of nature or war, you need enough Shamir Shares in other cities so that you don't lose your bitcoin.
At CoinSafe, we can withstand any individual city being taken out.
</p>

<p>
Also, try to give your shares out to people in different social groups to reduce any unlikely attempts at collusion.
Also, giving a share to people who are very close (e.g. a husband and wife pair) may lead the two of them to store their shares together (say in their safe).
If one is lost/destroyed, it's likely that both are.
Instruct the holders of your shares to keep it in a secure place and only reveal it to a designated party if you are dead/incapacitated.
They must also be sure that this designated party will carry out your wishes.
</p>

<p>
Congratulations, you've now created a system to secure your bitcoin the same way that large financial institutions do!
Whenever you want to put bitcoin in cold storage, simply send them to one (or more) of the addresses you generated in <code>btc_public_addresses.csv</code>.
When you want to spend some of that bitcoin, you'll have to go back to the bank vault and decrypt the file on the USB drive that has your bitcoin private key in it.
Don't walk down the street with those private keys in your pocket though, they should never leave your secure location!
You'll want to use a program to cryptographically sign your transactions from inside the bank vault.
More details coming on this in a future post.
</p>

<p>
Finally, remember that security systems are only as strong as their weakest link.
It's important to think like an attacker and put the risks in perspective.
You don't want to be guilty of making this mistake:<br />
<img src="https://s3.amazonaws.com/coinsafe-public/security.png" width="100%" /><br />
(HT <a href="http://xkcd.com/538/">xkcd</a>)</p>

<p><b>Remember, only the paranoid survive!</b></p>

<hr />

<a id="technical_notes"></a>
<h2>Technical Notes</h2>

<ul>
<li><a href="#biggest_threat">What is my biggest threat?</a></li>
<li><a href="#words_vs_letters">Random Words vs Random Letters</a></li>
<li><a href="#dividing_secrets">Warnings about Dividing a Secret</a></li>
<li><a href="#bip32">Can I use BIP 32 (Hierarchical Deterministic) Wallet?</a></li>
<li><a href="#bip38">Can I Use BIP38 to Encrypt and Store My Bitcoin?</a></li>
<li><a href="#wallet_libraries">What Other Libraries Are Good for Inspecting a Private Key?</a></li>
<li><a href="#destroy_pw">Doesn't destroying my decryption key mean I'm in trouble if I lose it?</a></li>
<li><a href="#bank_vaults">Why Use Bank Vaults?</a></li>
<li><a href="#fips140">Should I Use a FIPS 140 USB Drive?</a></li>
<li><a href="#openssl_security">Is OpenSSL Secure?</a></li>
<li><a href="#openssl_b64">Why do we base 64 encode the output from OpenSSL?</a></li>
<li><a href="#returning_from_vault">What if I get Mugged Returning from the Bank Vault After Signing Transactions Offline?</a></li>
<li><a href="#getting_to_vault">Should I Transfer My Encrypted USB Drives to the Bank Vault in Armored Car?</a></li>
<li><a href="#label_printer">My Handwriting is Terrible, Do I Have to Write Out all these Shamir Shares?</a></li>
<li><a href="#usb_longevity">Should I Store Copies On Something Else Besides USB Drives?</a></li>
<li><a href="#tampered_hardware">How Can I Be Sure My Computer's Hardware Wasn't Tampered With Before I Bought It?</a></li>
<li><a href="#usb_manufacturers">How Can I Be Sure the USB Drives Were In Fact Made In Different Facilities?</a></li>
<li><a href="#tails_overkill">Is Tails Overkill?</a></li>
<li><a href="#bitcoin_case">Is it Bitcoin or bitcoin?</a></li>
</ul>

<hr />

<a id="biggest_threat"></a>
<h3>What is my biggest threat?</h3>

<p>
There's no polite way to put this, but it's you!
You're probably more likely to mess up than to have someone go out of their way to specifically target your bitcoin.
For example, here's <a href="http://blockchain.info/charts/transaction-fees?timespan=all&showDataPoints=false&daysAverageString=1&show_header=true&scale=0&address=">a graph of total transaction fees paid on the bitcoin network</a>:<br />
<img src="https://s3.amazonaws.com/coinsafe-public/network_transaction_fees.png" width="100%" />
</p>

<p>
Think those people meant to spend 100 BTC to confirm a transaction when they could've spent <b>1 million times less</b>?
If we add up all the days with >200 BTC spent in transaction fees (~0.2% of all days) that amounts to ~1,000 BTC that was needlessly destroyed by user error.
To be fair, much of that was returned out of the generosity of miners, but it's a good example of how dangerous mistakes are.
The error they likely fell for (using their custom software and not explicitly including a change address) is a mistake that many smart people could easily fall for.
This stuff is complex!
</p>

<a id="words_vs_letters"></a>
<h3>Random Words vs Random Letters</h3>

<p>
Perhaps you're wondering why we don't generate our password using a bunch of words (kind of like a brain wallet)?
This would be great because studies show for the same amount of difficulty in remembering a password you can get even more entropy.
There are two problems with this approach:
</p>
<ul>
<li>
We later divide this secret using Shamir's Secret Sharing Scheme and by design the Shamir Shares will be even longer than the original decryption key (so that any combination of fewer shares than the threshold are worthless).
Because these have to be manually transcribed and stored, we don't want our decryption key to be longer than necessary.
</li>
<li>
What we're doing is fairly complex, and this introduces another place where we can mess it up.
When it comes to security, you're only as strong as your weakest link.
In other words: <a href="http://en.wikipedia.org/wiki/KISS_principle">Keep it simple, stupid</a>!
</li>
</ul>

<p>If you were going to go this route, this would be a simple way using <a href="https://github.com/onenameio/coinkit">coinkit</a>:<br />
<code>
>>> from coinkit.passphrase import random_160bit_passphrase<br />
>>> random_160bit_passphrase()<br />
</code>
</p>

<a id="dividing_secrets"></a>
<h3>Warnings about Dividing a Secret</h3>

<p>
Here's an example of a terrible scenario that is unfortunately a story we hear with some frequency.
A person has a randomly generated a 12 character password.
It has never touched the internet and was written down on a piece of a paper.
They take the paper and cut it in three parts, giving one piece to a trusted friend, another to a trusted relative and placing a third in their bank vault.
This is secure, right?
<b>No, this is terrible</b>.
</p>

<p>
Our primary concern in storing a secret is to prevent both theft and loss, so let's analyze what they've done from these two perspectives.
For theft, let's assume that one of the pieces of paper were compromised.
Now an attacker needs to only guess 8 of the 12 digits of the password.
In other words, we've gone from a 12 digit password to an 8 digit password.
Depending on the decryption algorithm, this could be a simple task on a normal household computer.
What most people aren't aware of is that because of the "exponential wall" a few extra characters in password length can be the difference between a secure password and one that is trivial to crack:
<img src="https://s3.amazonaws.com/coinsafe-public/exponential_problem.png" /><br />
(HT <a href="http://blog.erratasec.com/2012/06/linkedin-vs-password-cracking.html">Errata Security</a>)
</p>

<p>
Now let's move onto loss, where this system really falls apart.
Let's say that you lose your key (maybe the house is burgled and they take the safe, maybe there's a fire and it's hotter than your safe's rating or maybe the safe is in a damp place and the paper molds out).
The other two keys get you nothing and you've lost all your funds.
With Shamir, you could develop an m of n threshold that fits your needs.
</p>

<p>
This example is somewhat of a worst-case, but the takeaway is clear: <b>cryptographically dividing a secret is strictly superior to cutting it into pieces in all cases</b>.
Most other homegrown ideas are similarly bad.
Use Shamir, don't reinvent the wheel.
</p>

<a id="bip32"></a>
<h3>Can I use BIP 32 (Hierarchical Deterministic) Wallet?</h3>

<p>
An HD Wallet (described in <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP 32</a>) is really clever, and it has support from <a href="http://undefd.kaihola.fi/2013/08/23/programming-bitcoin-hd-wallets-in-python.html">pycoin</a> and <a href="https://github.com/vbuterin/pybitcointools">pybitcointools</a>, so it'd be easy enough to implement. Unfortunately, BIP32 has limited support to date from most libraries.
You'd be adding a fair amount of complexity for a minor benefit, which violates the <a href="http://en.wikipedia.org/wiki/Principle_of_least_astonishment">Principle of Least Astonishment</a>.
In other words, <a href="http://en.wikipedia.org/wiki/KISS_principle">Keep it simple, stupid</a>.
</p>

<a id="bip38"></a>
<h3>Can I Use BIP38 to Encrypt and Store My Bitcoin?</h3>

<p>
Absolutely, <a href="https://github.com/bitcoin/bips/blob/master/bip-0038.mediawiki">BIP38</a> is great.
The main use-case for BIP38 is encrypting a single wallet address, which is slightly different from what we're trying to do here in bulk.
It also has very limited support right now in wallet clients, but hopefully that will only improve.
Ben Davenport has <a href="https://github.com/bpdavenport/btc/blob/master/coldwallet.py">a nice script</a> you can use for this and <a href="https://www.bitaddress.org/">bitaddress.org</a> works as well.
</p>

<a id="wallet_libraries"></a>
<h3>What Other Libraries Are Good for Inspecting a Private Key?</h3>

<p>Here are some other alternatives to <a href="https://github.com/richardkiss/pycoin/">pycoin</a> and <a href="https://github.com/matja/bitcoin-tool">bitcoin-tool</a> if you're curious:</p>
<ul>
<li>
<a href="https://www.bitaddress.org/">bitaddress.org</a> is great (see "Bulk Wallet" and "Wallet Details" tabs), but isn't trivial to access at the command line since it's in javascript.
If you do that, please let us know how it worked out.
</li>
<li>
<a href="https://safepaperwallet.com/">safepaperwallet.com</a> looks great and is similar to bitaddress.org, but doesn't appear to have a feature where you can input a private key and see the corresponding public address.
</li>
<li>
<a href="https://github.com/casascius/Bitcoin-Address-Utility">Bitcoin Address Utility</a> looks like an excellent library, but we like <code>bitcoin-tool</code> since we avoid proprietary languages (like Microsoft's C#) when possible.
</li>
<li>
<a href="https://github.com/halfmoonlabs/coinkit">Coinkit</a> is a brand new library that is particularly good at generating brain wallets.
It also handles many different altcoin wallets.
</li>
</ul>

<p>If there are others we should know about, please <a href="/contact/">let us know</a>.</p>

<a id="destroy_pw"></a>
<h3>Doesn't destroying my decryption key mean I'm in trouble if I lose it?</h3>

<p>
Yes, it does. 
Fortunately, you have the guardians of your Shamir Shares who can help you recover it if needed (though not easily).
Leaving it laying around would be a huge vulnerability.
<a href="https://www.schneier.com/blog/archives/2005/06/write_down_your.html">Schneier advises people to keep written down passwords</a>, but that advice makes more sense when the stakes are low.
</p>

<a id="bank_vaults"></a>
<h3>Why Use Bank Vaults?</h3>

<p>
We could store everything in a brain wallet, with no physical component.
Information security is a relatively new field and humans are generally not very good at it.
Any one of dozens of mistakes could cost you your bitcoin.
Physical security is something we've been perfecting for millennia and is intuitive.
We're better protected against theft by using both types of security because they'd both need to be broken.
The only downside is that if we lose our physical storage we're out of luck.
However, as long as we use multiple redundant storage facilities we're protected against loss as well.
</p>

<p>
If you don't want physical storage (maybe you need to be able to access your funds without ever visiting a vault), <a href="http://maxtaco.github.io/bitcoin/2014/01/16/how-jason-bourne-stores-his-bitcoin/">WarpWallet</a> has a cool brain wallet implementation. Alternatively, you could more simply accomplish the same goal using <a href="https://www.bitaddress.org/">bitaddress.org</a> and a very long randomly generated password.
Regardless of which site you use, coinkit is great for generating a random passwords <a href="#words_vs_letters">as described above</a>.
This time, you want to call <code>random_256bit_passphrase()</code> as brain wallets require much more entropy than regular passwords.
</p>

<a id="fips140"></a>
<h3>Should I Use a FIPS 140 USB Drive?</h3>

<p>
<a href="http://en.wikipedia.org/wiki/FIPS_140">FIPS 140</a> refers to the Federal Information Processing Standards' 140 Publication Series on cryptographic modules and standards.
They range from requiring encryption to temper resistance and detection.
There are many <a href="http://www.pcworld.com/article/254816/the_best_encrypted_flash_drives.html">popular FIPS 140 USB drives</a>, though they often cost an order of magnitude more than their standard counterparts.
Unless you're a company that may one day fall under government purview (like CoinSafe), you probably won't benefit very much by spending money on these since everything is already encrypted.
Tamper-resistance/evidence is a nice feature, but discovering an attack after the fact is of little value here.
Since you should have USB drives in many locations (that you don't visit frequently), any tamper evidence would likely only be detected once it was far too late.
</p>

<a id="openssl_security"></a>
<h3>Is OpenSSL Secure?</h3>

<p>
There is some debate about this, and we recommend you read <a href="http://security.stackexchange.com/questions/29106/openssl-recover-key-and-iv-by-passphrase/29139#29139">Thomas Pornin's excellent critique of file encryption using openSSL</a>.
However, there are some very solid reasons to use OpenSSL:
</p>
<ul>
  <li>
  Given that we want to only access these USB drive using a machine running on Tails, it makes sense to choose a library that is included on the Tails Live OS.
  Unfortunately, TrueCrypt is not natively included and <a href="https://tails.boum.org/doc/encryption_and_privacy/truecrypt/">there are valid criticisms of it</a>
  </li>
  <li>
  It's massively popular and (relatively) old, so it should be one of the most well-tested/vetted libraries out there.
  </li>
</ul>
<p>
It's also worth noting that we use much more entropy than Thomas's warning recommends and are considering a switch to <code>gpg</code> in the future.
</p>

<p>
While the recent <a href="http://heartbleed.com/">Heartbleed vulnerability</a> certainly is a black-mark for OpenSSL, it has no effect here.
Heartbleed can be used to compromise a machine with unencrypted private data on it.
In our case, the data is encrypted and the software has no idea how to decrypt it, so this attack vector doesn't exist.
</p>

<a id="openssl_b64"></a>
<h3>Why do we base 64 encode the output from OpenSSL?</h3>

<p>
We use the <code>-a</code> flag because the output is easier to read when base64 encoded.
Since this file is only ever going to be read by a computer, the <code>-a</code> flag is not strictly necessary.
If you'd like to learn more about OpenSSL, there's a good tutorial <a href="http://www.madboa.com/geek/openssl/">here</a>.
</p>

<a id="returning_from_vault"></a>
<h3>What if I get Mugged Returning from the Bank Vault After Signing Transactions Offline?</h3>

<p>
The signed transactions don't reveal your private key, but they do reveal the public key for that wallet address.
This protection was put in place by Satoshi to protect against quantum computers, which aren't known to exist yet.
If they are, they'd be used to do much more valuable things than rob you.
</p>

<p>Put differently: the signed transactions are what you're about to broadcast to miners; nobody else would benefit by having them first.</p>

<a id="getting_to_vault"></a>
<h3>Should I Transfer My Encrypted USB Drives to the Bank Vault in Armored Car?</h3>

<p>
Only if you plan on being shot at! A much simpler option is to encrypt the file with a very long password and then separately transport the encrypted USB with another party.
That long password must stay in your direct possession at all times. When you both (separately) arrive at the bank vault, follow these steps:
</p>
<ol>
  <li><b>Decrypt the USB drive</b> - be mindful of where you store this data using the same procedures we demonstrated above</li>
  <li>
  <b>Destroy that decryption key</b> - someone might've intercepted the USB drive in transit and made a copy.
  The decryption key is the only thing between them and your private data.
  </li>
  <li><b>Encrypt the USB drive using your original secure password</b> - it can never sit around anywhere unencrypted.</li>
</ol>

<p>At CoinSafe, the way we solve this problem is to start by encrypting the already encrypted file (<code>btc_keys_20140113_2058.enc</code> in our example above) so that decrypting the transported file reveals the original encrypted file.</p>

<p>
One cool part about this system is that any insecure mail courier would work (even regular mail if the bank would accept delivery on your behalf) as long as you are <b>absolutely certain</b> that your decryption key has never been compromised.
Once you decrypt the files and destroy the decryption key, any copies that might've been made during transport would be rendered worthless.
At CoinSafe, we transport our USB drives ourselves and use the extra encryption redundancy so that we don't have to take that chance.
</p>

<a id="label_printer"></a>
<h3>My Handwriting is Terrible, Do I Have to Write Out all these Shamir Shares?</h3>

<p>A mechanical label printer (like <a href="http://www.amazon.com/DYMO-Organizer-Xpress-Pro-Line/dp/B004E2RQO8">this one</a>) would be better, but unfortunately we couldn't find one that supports lowercase letters.</p>

<p>If we were doing this often, we might want to set up a label printer that we could use from our computer so we can just hit print, but then we'd have to deal with two other issues:</p>
<ul>
  <li>We have to make sure that our smart label printer has no local memory storage.</li>
  <li>Driver support may be limited.</li>
</ul>

<p>If anyone has experience with this aspect, please <a href="/contact/">let us know a good printer to use!</a></p>

<a id="usb_longevity"></a>
<h3>Should I Store Copies on Something Else Besides USB Drives?</h3>

<p>
USB drives are very cheap and last a long time (estimates <a href="http://cfgearblog.blogspot.com/2014/01/cfgear-delivers-rush-bulk-flash-drives.html">vary</a> <a href="http://agogified.com/97">widely</a>, but 10-50 years is often cited).
Because we visit the bank vaults frequently, we can easily verify the validity of a file by confirming its SHA256 hash matches what we previously calculated.
It's easy to periodically cycle in a new USB drive to the vault and copy the encrypted files onto it for increased longevity.
We're investigating using another medium to provide more redundancy, but given the quantity of data we need to store paper is not a practical option.
This would be one benefit of using <a href="#bip32">BIP32</a>.
</p>

<p>Here's <a href="http://www.coolinfographics.com/blog/2012/8/14/the-lifespan-of-storage-media.html">a fun infographic comparing different storage methods</a> if you're curious.<p>

<a id="tampered_hardware"></a>
<h3>How Can I Be Sure My Computer's Hardware Wasn't Tampered With Before I Bought It?</h3>

<p>
Unfortunately, it's really hard!
One benefit of using an older computer is that the odds the hardware was tampered with by a three letter agency is probably reduced.
Without a CSPRNG, it's really tough to do proper cryptography.
Adding user-generated entropy is always a good countermeasure.
</p>

<a id="usb_manufacturers"></a>
<h3>How Can I Be Sure the USB Drives Were In Fact Made In Different Facilities?</h3>

<p>
Unfortunately, it can be hard to tell and this is part of the reason we use more redundant copies than we need.
One trick is to look for ones that are clearly of different sizes, though that's a fairly weak guarantee.
For example, it's unlikely the <a href="http://www.amazon.com/SanDisk-Cruzer-Flash-Drive-SDCZ33-032G-B35/dp/B00812F7O8/">SanDisk Cruzer</a> and the <a href="http://www.amazon.com/Kingston-Digital-DataTraveler-DTSE9H-16GBZET/dp/B00DYQYITG/">Kingston Digital DataTraveler</a> are the same hardware under the hood.
</p>

<p>
One nice thing about our system is that whenever we visit the bank vault, we can easily verify the validity of our encrypted file by taking the SHA256 of it and confirming it matches what we wrote down when we original set everything up:<br />
<code>
$ shasum -a 256 /media/securedrive/btc_keys_20140113_2058.enc
</code><br />
It's trivial to cycle in a brand new USB drive every year or so by bringing our airgap machine into the vault and copying the file onto a new USB drive.
</p>

<a id="tails_overkill"></a>
<h3>Is Tails Overkill?</h3>

<p>
We were once testing that everything was working by decrypting the contents of a sensitive USB drive.
Instead of typing the decryption command and then waiting for a password prompt, we typed the decryption key directly into the command line and hit enter.
Of course this is not a valid command and so we get an error message.
What's the big deal? On a normal Linux distro, that command would've been saved in <code>.bash_history</code> where any snooping eyes who later got access to the physical hardware could peak.
With Tails, this is not a problem.
Regardless, to be safe CoinSafe immediately retired that decryption key and all the private keys it was protecting.
</p>

<a id="bitcoin_case"></a>
<h3>Is it Bitcoin or bitcoin?</h3>

<p>
bitcoin (lowercase) is the currency and Bitcoin (uppercase) is the protocol.
This naming convention was probably a bad design decision, but we're stuck with it now.
</p>

<a id="thank_you"></a>
<h3>Closing Thank You</h3>

<p>
Designing this system was not an overnight process and we'd like to thank several people who played a role in helping design and test it:
<a href="http://blog.richardkiss.com/">Richard Kiss</a>, <a href="https://github.com/matja/">Mat Anger</a>, <a href="http://ryaneshea.com/">Ryan Shea</a>, <a href="http://andrewbadr.com/">Andrew Badr</a>, <a href="http://mises.org/daily/author/1486/">Vijay Boyapati</a>, <a href="https://bitcointalk.org/index.php?action=profile;u=88950">jedunnigan</a>, <a href="http://www.linkedin.com/pub/jason-wu/21/8a5/5b1">Jason Wu</a>, <a href="http://www.linkedin.com/pub/philippe-camacho/2/19/b5">Philippe Camacho</a>, <a href="https://twitter.com/adamtait">Adam Tait</a>, <a href="https://twitter.com/cmueller">Chris Mueller</a>, <a href="https://www.facebook.com/andrew.wiedemann.5">Andrew Wiedemann</a>, <a href="http://www.linkedin.com/pub/adam-cozzette/2b/5ab/59b">Adam Cozzette</a>, <a href="http://www.linkedin.com/in/ebbyamir">Ebby Amir</a>, <a href="http://www.linkedin.com/in/bjennelle">Blake Jennelle</a> and more!
</p>

<hr />

{% endblock main_section %}


{% block static_page_footer %}
  {% include "partials/_static_page_footer.html" %}
{% endblock static_page_footer %}
